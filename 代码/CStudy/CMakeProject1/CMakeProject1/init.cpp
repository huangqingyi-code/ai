//对象的初始化和清理
//构造函数和析构函数  被编译器自动调用   如果我们不提供编译器提供的构造和析构是空实现
//
//构造函数语法：  在实例化后调用
//1.构造函数没有返回值，也不会写void；2.函数名与类名相同；3.构造函数可以有参数，因此可以发生重载4.会自动调用
//析构函数语法：  在程序结束前调用
//析构函数也没有返回值，也不会写void；2.函数名与类名相同，前面加~；3.不可以有参数4.自动调用

//构造函数分类：1.有参构造无参构造2.普通构造和拷贝构造
//构造函数的调用：1.括号发2.显示法3.隐式转换法

//拷贝构造函数的调用时机：1.使用一个已经创建完毕的对象来初始化一个新对象2.值传递的方式给函数参数传值3.以值方式返回局部对象

//构造函数调用规则，c++编译器至少给一个类添加3个函数：1.默认构造函数2.默认析构函数3.默认拷贝构造函数，对属性进行值拷贝。
//1.如果用户定义了有参构造函数，编译器不会提供默认构造函数但会提供默认拷贝构造函数
//2.如果用户定义了拷贝构造函数，编译器不会提供默认构造和有参构造函数

//深拷贝和浅拷贝：浅拷贝：简单的赋值拷贝操作；深拷贝：在堆区重新申请空间，进行拷贝操作
//如果属性有在堆区开辟，一定要自己提供拷贝构造函数，深拷贝，防止浅拷贝带来的问题

//初始化列表  Person(int a ,int b,int c):a_age = (a),b_age=（b）,c_age=(c){}
#include<iostream>
using namespace std;
class Person
{
public:
	int *m_age;
	Person(int age)
	{
		m_age = new int(age);
		cout << "调用构造函数" << endl;
	}
	Person(const Person &p)
	{
		m_age = new int(*p.m_age);  //深拷贝，在堆区重新创建内存空间
	}
	~Person()    //析构函数可以释放堆区内存
	{
		if (m_age != NULL)   //如果用浅拷贝会造成，堆区的内存会重复释放，要用深拷贝，自己创建拷贝构造函数
		{
			delete m_age;
		}
		m_age = NULL;
		cout << "调用析构函数" << endl;
	}
};

//void test()
//{
//	Person alex;   //在栈区函数结束后自动清空，清空前会调用析构函数
//}
//Person test02()
//{
//	Person wusir;
//	cout << &wusir << endl;
//	return wusir;    //返回的这个对象是重新创建的，不是上面栈区的对象
//}
void test03()
{
	Person wusir(20);
	cout << *wusir.m_age << endl;
	Person alex(wusir);
	cout << *alex.m_age << endl;
}

int main()
{
    test03();
	system("pause");
	return 0;
}